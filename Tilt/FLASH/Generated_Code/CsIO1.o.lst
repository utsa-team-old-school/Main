   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"CsIO1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.__read_console,"ax",%progbits
  18              		.align	2
  19              		.global	__read_console
  20              		.code	16
  21              		.thumb_func
  23              	__read_console:
  24              	.LFB0:
  25              		.file 1 "../Generated_Code/CsIO1.c"
   1:../Generated_Code/CsIO1.c **** /* ###################################################################
   2:../Generated_Code/CsIO1.c **** **     This component module is generated by Processor Expert. Do not modify it.
   3:../Generated_Code/CsIO1.c **** **     Filename    : CsIO1.c
   4:../Generated_Code/CsIO1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/CsIO1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/CsIO1.c **** **     Component   : ConsoleIO
   7:../Generated_Code/CsIO1.c **** **     Version     : Component 01.016, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/CsIO1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/CsIO1.c **** **     Date/Time   : 2019-03-27, 16:14, # CodeGen: 58
  10:../Generated_Code/CsIO1.c **** **     Abstract    :
  11:../Generated_Code/CsIO1.c **** **         This component generates low-level methods for redirecting console I/O to the selected U
  12:../Generated_Code/CsIO1.c **** **         These methods are typically used by printf()/scanf() methods.
  13:../Generated_Code/CsIO1.c **** **     Settings    :
  14:../Generated_Code/CsIO1.c **** **          Component name                                 : CsIO1
  15:../Generated_Code/CsIO1.c **** **          Serial_LDD_Link                                : ConsoleIO_Serial_LDD
  16:../Generated_Code/CsIO1.c **** **     Contents    :
  17:../Generated_Code/CsIO1.c **** **         No public methods
  18:../Generated_Code/CsIO1.c **** **
  19:../Generated_Code/CsIO1.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  20:../Generated_Code/CsIO1.c **** **     All Rights Reserved.
  21:../Generated_Code/CsIO1.c **** **     
  22:../Generated_Code/CsIO1.c **** **     Redistribution and use in source and binary forms, with or without modification,
  23:../Generated_Code/CsIO1.c **** **     are permitted provided that the following conditions are met:
  24:../Generated_Code/CsIO1.c **** **     
  25:../Generated_Code/CsIO1.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  26:../Generated_Code/CsIO1.c **** **       of conditions and the following disclaimer.
  27:../Generated_Code/CsIO1.c **** **     
  28:../Generated_Code/CsIO1.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  29:../Generated_Code/CsIO1.c **** **       list of conditions and the following disclaimer in the documentation and/or
  30:../Generated_Code/CsIO1.c **** **       other materials provided with the distribution.
  31:../Generated_Code/CsIO1.c **** **     
  32:../Generated_Code/CsIO1.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  33:../Generated_Code/CsIO1.c **** **       contributors may be used to endorse or promote products derived from this
  34:../Generated_Code/CsIO1.c **** **       software without specific prior written permission.
  35:../Generated_Code/CsIO1.c **** **     
  36:../Generated_Code/CsIO1.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  37:../Generated_Code/CsIO1.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  38:../Generated_Code/CsIO1.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  39:../Generated_Code/CsIO1.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  40:../Generated_Code/CsIO1.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  41:../Generated_Code/CsIO1.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  42:../Generated_Code/CsIO1.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  43:../Generated_Code/CsIO1.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  44:../Generated_Code/CsIO1.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  45:../Generated_Code/CsIO1.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  46:../Generated_Code/CsIO1.c **** **     
  47:../Generated_Code/CsIO1.c **** **     http: www.freescale.com
  48:../Generated_Code/CsIO1.c **** **     mail: support@freescale.com
  49:../Generated_Code/CsIO1.c **** ** ###################################################################*/
  50:../Generated_Code/CsIO1.c **** /*!
  51:../Generated_Code/CsIO1.c **** ** @file CsIO1.c
  52:../Generated_Code/CsIO1.c **** ** @version 01.00
  53:../Generated_Code/CsIO1.c **** ** @brief
  54:../Generated_Code/CsIO1.c **** **         This component generates low-level methods for redirecting console I/O to the selected U
  55:../Generated_Code/CsIO1.c **** **         These methods are typically used by printf()/scanf() methods.
  56:../Generated_Code/CsIO1.c **** */         
  57:../Generated_Code/CsIO1.c **** /*!
  58:../Generated_Code/CsIO1.c **** **  @addtogroup CsIO1_module CsIO1 module documentation
  59:../Generated_Code/CsIO1.c **** **  @{
  60:../Generated_Code/CsIO1.c **** */         
  61:../Generated_Code/CsIO1.c **** 
  62:../Generated_Code/CsIO1.c **** /* MODULE CsIO1. */
  63:../Generated_Code/CsIO1.c **** 
  64:../Generated_Code/CsIO1.c **** #include "IO_Map.h"
  65:../Generated_Code/CsIO1.c **** #include "stdio.h"
  66:../Generated_Code/CsIO1.c **** #include <stdarg.h>
  67:../Generated_Code/CsIO1.c **** #include "UART0_PDD.h"
  68:../Generated_Code/CsIO1.c **** 
  69:../Generated_Code/CsIO1.c **** #ifdef _EWL_STDINT_H
  70:../Generated_Code/CsIO1.c **** 
  71:../Generated_Code/CsIO1.c **** /*
  72:../Generated_Code/CsIO1.c **** ** ===================================================================
  73:../Generated_Code/CsIO1.c **** **     Method      :  CsIO1___read_console (component ConsoleIO)
  74:../Generated_Code/CsIO1.c **** **
  75:../Generated_Code/CsIO1.c **** **     Description :
  76:../Generated_Code/CsIO1.c **** **         __read_console
  77:../Generated_Code/CsIO1.c **** **         This method is internal. It is used by Processor Expert only.
  78:../Generated_Code/CsIO1.c **** ** ===================================================================
  79:../Generated_Code/CsIO1.c **** */
  80:../Generated_Code/CsIO1.c **** int __read_console(__file_handle handle, unsigned char* buffer, size_t * count)
  81:../Generated_Code/CsIO1.c **** {
  26              		.loc 1 81 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 86B0     		sub	sp, sp, #24
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 32
  36 0004 00AF     		add	r7, sp, #0
  37              	.LCFI2:
  38              		.cfi_def_cfa_register 7
  39 0006 F860     		str	r0, [r7, #12]
  40 0008 B960     		str	r1, [r7, #8]
  41 000a 7A60     		str	r2, [r7, #4]
  82:../Generated_Code/CsIO1.c ****   size_t CharCnt = 0x00;
  42              		.loc 1 82 0
  43 000c 0023     		mov	r3, #0
  44 000e 7B61     		str	r3, [r7, #20]
  83:../Generated_Code/CsIO1.c **** 
  84:../Generated_Code/CsIO1.c ****   (void)handle;                        /* Parameter is not used, suppress unused argument warning *
  85:../Generated_Code/CsIO1.c ****   for (;*count > 0x00; --*count) {
  45              		.loc 1 85 0
  46 0010 2CE0     		b	.L2
  47              	.L8:
  86:../Generated_Code/CsIO1.c ****     if ((UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART0_S1_RDRF_MASK) == 0x00) { /* Any d
  48              		.loc 1 86 0
  49 0012 1D4B     		ldr	r3, .L11
  50 0014 1B79     		ldrb	r3, [r3, #4]
  51 0016 DBB2     		uxtb	r3, r3
  52 0018 1A1C     		mov	r2, r3
  53 001a 2023     		mov	r3, #32
  54 001c 1340     		and	r3, r2
  55 001e 0DD1     		bne	.L3
  87:../Generated_Code/CsIO1.c ****       /* Clear error flags */
  88:../Generated_Code/CsIO1.c ****       UART0_PDD_ClearInterruptFlags(UART0_BASE_PTR,0x1FU);
  56              		.loc 1 88 0
  57 0020 194B     		ldr	r3, .L11
  58 0022 1F22     		mov	r2, #31
  59 0024 1A71     		strb	r2, [r3, #4]
  89:../Generated_Code/CsIO1.c ****       if (CharCnt != 0x00) {           /* No, at least one char received? */
  60              		.loc 1 89 0
  61 0026 7B69     		ldr	r3, [r7, #20]
  62 0028 002B     		cmp	r3, #0
  63 002a 24D1     		bne	.L10
  90:../Generated_Code/CsIO1.c ****         break;                         /* Yes, return received char(s) */
  91:../Generated_Code/CsIO1.c ****       } else {                         /* Wait until a char is received */
  92:../Generated_Code/CsIO1.c ****         while ((UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART0_S1_RDRF_MASK) == 0x00) {};
  64              		.loc 1 92 0
  65 002c C046     		mov	r8, r8
  66              	.L6:
  67              		.loc 1 92 0 is_stmt 0
  68 002e 164B     		ldr	r3, .L11
  69 0030 1B79     		ldrb	r3, [r3, #4]
  70 0032 DBB2     		uxtb	r3, r3
  71 0034 1A1C     		mov	r2, r3
  72 0036 2023     		mov	r3, #32
  73 0038 1340     		and	r3, r2
  74 003a F8D0     		beq	.L6
  75              	.L3:
  93:../Generated_Code/CsIO1.c ****       }
  94:../Generated_Code/CsIO1.c ****     }
  95:../Generated_Code/CsIO1.c ****     CharCnt++;                         /* Increase char counter */
  76              		.loc 1 95 0 is_stmt 1
  77 003c 7B69     		ldr	r3, [r7, #20]
  78 003e 0133     		add	r3, r3, #1
  79 0040 7B61     		str	r3, [r7, #20]
  96:../Generated_Code/CsIO1.c ****     /* Save character received by UARTx device into the receive buffer */
  97:../Generated_Code/CsIO1.c ****     *buffer = (unsigned char)UART0_PDD_GetChar8(UART0_BASE_PTR);
  80              		.loc 1 97 0
  81 0042 114B     		ldr	r3, .L11
  82 0044 DB79     		ldrb	r3, [r3, #7]
  83 0046 DAB2     		uxtb	r2, r3
  84 0048 BB68     		ldr	r3, [r7, #8]
  85 004a 1A70     		strb	r2, [r3]
  98:../Generated_Code/CsIO1.c ****     /* Stop reading if CR (Ox0D) character is received */
  99:../Generated_Code/CsIO1.c ****     if (*buffer == 0x0DU) {            /* New line character (CR) received ? */
  86              		.loc 1 99 0
  87 004c BB68     		ldr	r3, [r7, #8]
  88 004e 1B78     		ldrb	r3, [r3]
  89 0050 0D2B     		cmp	r3, #13
  90 0052 03D1     		bne	.L7
 100:../Generated_Code/CsIO1.c ****       *buffer = '\n';                  /* Yes, convert LF to '\n' char. */
  91              		.loc 1 100 0
  92 0054 BB68     		ldr	r3, [r7, #8]
  93 0056 0A22     		mov	r2, #10
  94 0058 1A70     		strb	r2, [r3]
 101:../Generated_Code/CsIO1.c ****       break;                           /* Stop loop and return received char(s) */
  95              		.loc 1 101 0
  96 005a 0DE0     		b	.L5
  97              	.L7:
 102:../Generated_Code/CsIO1.c ****     }
 103:../Generated_Code/CsIO1.c ****     buffer++;                          /* Increase buffer pointer */
  98              		.loc 1 103 0
  99 005c BB68     		ldr	r3, [r7, #8]
 100 005e 0133     		add	r3, r3, #1
 101 0060 BB60     		str	r3, [r7, #8]
  85:../Generated_Code/CsIO1.c ****   for (;*count > 0x00; --*count) {
 102              		.loc 1 85 0
 103 0062 7B68     		ldr	r3, [r7, #4]
 104 0064 1B68     		ldr	r3, [r3]
 105 0066 5A1E     		sub	r2, r3, #1
 106 0068 7B68     		ldr	r3, [r7, #4]
 107 006a 1A60     		str	r2, [r3]
 108              	.L2:
  85:../Generated_Code/CsIO1.c ****   for (;*count > 0x00; --*count) {
 109              		.loc 1 85 0 is_stmt 0
 110 006c 7B68     		ldr	r3, [r7, #4]
 111 006e 1B68     		ldr	r3, [r3]
 112 0070 002B     		cmp	r3, #0
 113 0072 CED1     		bne	.L8
 114 0074 00E0     		b	.L5
 115              	.L10:
  90:../Generated_Code/CsIO1.c ****         break;                         /* Yes, return received char(s) */
 116              		.loc 1 90 0 is_stmt 1
 117 0076 C046     		mov	r8, r8
 118              	.L5:
 104:../Generated_Code/CsIO1.c ****   }
 105:../Generated_Code/CsIO1.c ****   *count = CharCnt;
 119              		.loc 1 105 0
 120 0078 7B68     		ldr	r3, [r7, #4]
 121 007a 7A69     		ldr	r2, [r7, #20]
 122 007c 1A60     		str	r2, [r3]
 106:../Generated_Code/CsIO1.c ****   return (__no_io_error);
 123              		.loc 1 106 0
 124 007e 0023     		mov	r3, #0
 107:../Generated_Code/CsIO1.c **** }
 125              		.loc 1 107 0
 126 0080 181C     		mov	r0, r3
 127 0082 BD46     		mov	sp, r7
 128 0084 06B0     		add	sp, sp, #24
 129              		@ sp needed for prologue
 130 0086 80BD     		pop	{r7, pc}
 131              	.L12:
 132              		.align	2
 133              	.L11:
 134 0088 00A00640 		.word	1074176000
 135              		.cfi_endproc
 136              	.LFE0:
 138              		.section	.text.__write_console,"ax",%progbits
 139              		.align	2
 140              		.global	__write_console
 141              		.code	16
 142              		.thumb_func
 144              	__write_console:
 145              	.LFB1:
 108:../Generated_Code/CsIO1.c **** 
 109:../Generated_Code/CsIO1.c **** /*
 110:../Generated_Code/CsIO1.c **** ** ===================================================================
 111:../Generated_Code/CsIO1.c **** **     Method      :  CsIO1___write_console (component ConsoleIO)
 112:../Generated_Code/CsIO1.c **** **
 113:../Generated_Code/CsIO1.c **** **     Description :
 114:../Generated_Code/CsIO1.c **** **         __write_console
 115:../Generated_Code/CsIO1.c **** **         This method is internal. It is used by Processor Expert only.
 116:../Generated_Code/CsIO1.c **** ** ===================================================================
 117:../Generated_Code/CsIO1.c **** */
 118:../Generated_Code/CsIO1.c **** int __write_console(__file_handle handle, unsigned char* buffer, size_t* count)
 119:../Generated_Code/CsIO1.c **** {
 146              		.loc 1 119 0
 147              		.cfi_startproc
 148 0000 80B5     		push	{r7, lr}
 149              	.LCFI3:
 150              		.cfi_def_cfa_offset 8
 151              		.cfi_offset 7, -8
 152              		.cfi_offset 14, -4
 153 0002 86B0     		sub	sp, sp, #24
 154              	.LCFI4:
 155              		.cfi_def_cfa_offset 32
 156 0004 00AF     		add	r7, sp, #0
 157              	.LCFI5:
 158              		.cfi_def_cfa_register 7
 159 0006 F860     		str	r0, [r7, #12]
 160 0008 B960     		str	r1, [r7, #8]
 161 000a 7A60     		str	r2, [r7, #4]
 120:../Generated_Code/CsIO1.c ****   size_t CharCnt = 0x00;
 162              		.loc 1 120 0
 163 000c 0023     		mov	r3, #0
 164 000e 7B61     		str	r3, [r7, #20]
 121:../Generated_Code/CsIO1.c **** 
 122:../Generated_Code/CsIO1.c ****   (void)handle;                        /* Parameter is not used, suppress unused argument warning *
 123:../Generated_Code/CsIO1.c ****   for (;*count > 0x00; --*count) {
 165              		.loc 1 123 0
 166 0010 25E0     		b	.L14
 167              	.L20:
 124:../Generated_Code/CsIO1.c ****     /* Wait until UART is ready for saving a next character into the transmit buffer */
 125:../Generated_Code/CsIO1.c ****     while ((UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART0_S1_TDRE_MASK) == 0) {};
 168              		.loc 1 125 0
 169 0012 C046     		mov	r8, r8
 170              	.L15:
 171              		.loc 1 125 0 is_stmt 0
 172 0014 184B     		ldr	r3, .L21
 173 0016 1B79     		ldrb	r3, [r3, #4]
 174 0018 DBB2     		uxtb	r3, r3
 175 001a DBB2     		uxtb	r3, r3
 176 001c 5BB2     		sxtb	r3, r3
 177 001e 002B     		cmp	r3, #0
 178 0020 F8DA     		bge	.L15
 126:../Generated_Code/CsIO1.c ****     if (*buffer == '\n') {
 179              		.loc 1 126 0 is_stmt 1
 180 0022 BB68     		ldr	r3, [r7, #8]
 181 0024 1B78     		ldrb	r3, [r3]
 182 0026 0A2B     		cmp	r3, #10
 183 0028 0AD1     		bne	.L16
 127:../Generated_Code/CsIO1.c ****       /* Send '\r'(0x0D) before each '\n'(0x0A). */
 128:../Generated_Code/CsIO1.c ****       /* Save a character into the transmit buffer of the UART0 device */
 129:../Generated_Code/CsIO1.c ****       UART0_PDD_PutChar8(UART0_BASE_PTR, 0x0DU);
 184              		.loc 1 129 0
 185 002a 134B     		ldr	r3, .L21
 186 002c 0D22     		mov	r2, #13
 187 002e DA71     		strb	r2, [r3, #7]
 130:../Generated_Code/CsIO1.c ****       /* Wait until UART is ready for saving a next character into the transmit buffer */
 131:../Generated_Code/CsIO1.c ****       while ((UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR) & UART0_S1_TDRE_MASK) == 0) {};
 188              		.loc 1 131 0
 189 0030 C046     		mov	r8, r8
 190              	.L17:
 191              		.loc 1 131 0 is_stmt 0
 192 0032 114B     		ldr	r3, .L21
 193 0034 1B79     		ldrb	r3, [r3, #4]
 194 0036 DBB2     		uxtb	r3, r3
 195 0038 DBB2     		uxtb	r3, r3
 196 003a 5BB2     		sxtb	r3, r3
 197 003c 002B     		cmp	r3, #0
 198 003e F8DA     		bge	.L17
 199              	.L16:
 132:../Generated_Code/CsIO1.c ****     }
 133:../Generated_Code/CsIO1.c ****     /* Save a character into the transmit buffer of the UART0 device */
 134:../Generated_Code/CsIO1.c ****     UART0_PDD_PutChar8(UART0_BASE_PTR, (unsigned char)*buffer);
 200              		.loc 1 134 0 is_stmt 1
 201 0040 0D4B     		ldr	r3, .L21
 202 0042 BA68     		ldr	r2, [r7, #8]
 203 0044 1278     		ldrb	r2, [r2]
 204 0046 DA71     		strb	r2, [r3, #7]
 135:../Generated_Code/CsIO1.c ****     buffer++;                          /* Increase buffer pointer */
 205              		.loc 1 135 0
 206 0048 BB68     		ldr	r3, [r7, #8]
 207 004a 0133     		add	r3, r3, #1
 208 004c BB60     		str	r3, [r7, #8]
 136:../Generated_Code/CsIO1.c ****     CharCnt++;                         /* Increase char counter */
 209              		.loc 1 136 0
 210 004e 7B69     		ldr	r3, [r7, #20]
 211 0050 0133     		add	r3, r3, #1
 212 0052 7B61     		str	r3, [r7, #20]
 123:../Generated_Code/CsIO1.c ****   for (;*count > 0x00; --*count) {
 213              		.loc 1 123 0
 214 0054 7B68     		ldr	r3, [r7, #4]
 215 0056 1B68     		ldr	r3, [r3]
 216 0058 5A1E     		sub	r2, r3, #1
 217 005a 7B68     		ldr	r3, [r7, #4]
 218 005c 1A60     		str	r2, [r3]
 219              	.L14:
 123:../Generated_Code/CsIO1.c ****   for (;*count > 0x00; --*count) {
 220              		.loc 1 123 0 is_stmt 0
 221 005e 7B68     		ldr	r3, [r7, #4]
 222 0060 1B68     		ldr	r3, [r3]
 223 0062 002B     		cmp	r3, #0
 224 0064 D5D1     		bne	.L20
 137:../Generated_Code/CsIO1.c ****   }
 138:../Generated_Code/CsIO1.c ****   *count = CharCnt;
 225              		.loc 1 138 0 is_stmt 1
 226 0066 7B68     		ldr	r3, [r7, #4]
 227 0068 7A69     		ldr	r2, [r7, #20]
 228 006a 1A60     		str	r2, [r3]
 139:../Generated_Code/CsIO1.c ****   return(__no_io_error);
 229              		.loc 1 139 0
 230 006c 0023     		mov	r3, #0
 140:../Generated_Code/CsIO1.c **** }
 231              		.loc 1 140 0
 232 006e 181C     		mov	r0, r3
 233 0070 BD46     		mov	sp, r7
 234 0072 06B0     		add	sp, sp, #24
 235              		@ sp needed for prologue
 236 0074 80BD     		pop	{r7, pc}
 237              	.L22:
 238 0076 C046     		.align	2
 239              	.L21:
 240 0078 00A00640 		.word	1074176000
 241              		.cfi_endproc
 242              	.LFE1:
 244              		.section	.text.__close_console,"ax",%progbits
 245              		.align	2
 246              		.global	__close_console
 247              		.code	16
 248              		.thumb_func
 250              	__close_console:
 251              	.LFB2:
 141:../Generated_Code/CsIO1.c **** 
 142:../Generated_Code/CsIO1.c **** /*
 143:../Generated_Code/CsIO1.c **** ** ===================================================================
 144:../Generated_Code/CsIO1.c **** **     Method      :  CsIO1___close_console (component ConsoleIO)
 145:../Generated_Code/CsIO1.c **** **
 146:../Generated_Code/CsIO1.c **** **     Description :
 147:../Generated_Code/CsIO1.c **** **         __close_console
 148:../Generated_Code/CsIO1.c **** **         This method is internal. It is used by Processor Expert only.
 149:../Generated_Code/CsIO1.c **** ** ===================================================================
 150:../Generated_Code/CsIO1.c **** */
 151:../Generated_Code/CsIO1.c **** int __close_console(__file_handle handle)
 152:../Generated_Code/CsIO1.c **** {
 252              		.loc 1 152 0
 253              		.cfi_startproc
 254 0000 80B5     		push	{r7, lr}
 255              	.LCFI6:
 256              		.cfi_def_cfa_offset 8
 257              		.cfi_offset 7, -8
 258              		.cfi_offset 14, -4
 259 0002 82B0     		sub	sp, sp, #8
 260              	.LCFI7:
 261              		.cfi_def_cfa_offset 16
 262 0004 00AF     		add	r7, sp, #0
 263              	.LCFI8:
 264              		.cfi_def_cfa_register 7
 265 0006 7860     		str	r0, [r7, #4]
 153:../Generated_Code/CsIO1.c ****   (void)handle;                        /* Parameter is not used, suppress unused argument warning *
 154:../Generated_Code/CsIO1.c ****   return(__no_io_error);
 266              		.loc 1 154 0
 267 0008 0023     		mov	r3, #0
 155:../Generated_Code/CsIO1.c **** }
 268              		.loc 1 155 0
 269 000a 181C     		mov	r0, r3
 270 000c BD46     		mov	sp, r7
 271 000e 02B0     		add	sp, sp, #8
 272              		@ sp needed for prologue
 273 0010 80BD     		pop	{r7, pc}
 274              		.cfi_endproc
 275              	.LFE2:
 277 0012 C046     		.text
 278              	.Letext0:
 279              		.file 2 "D:/Freescale/CW MCU v10.7/MCU/ProcessorExpert/lib/Kinetis/iofiles/MKL25Z4.h"
 280              		.file 3 "D:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 281              		.file 4 "D:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
 282              		.file 5 "D:/Freescale/CW MCU v10.7/MCU/ARM_GCC_Support/ewl/EWL_C/include/file_struc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CsIO1.c
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:18     .text.__read_console:00000000 $t
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:23     .text.__read_console:00000000 __read_console
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:134    .text.__read_console:00000088 $d
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:139    .text.__write_console:00000000 $t
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:144    .text.__write_console:00000000 __write_console
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:240    .text.__write_console:00000078 $d
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:245    .text.__close_console:00000000 $t
C:\Users\JOSHUA~1\AppData\Local\Temp\ccbchrou.s:250    .text.__close_console:00000000 __close_console
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
